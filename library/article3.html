<html>

<head>
    <title>Библиотека - Варяник Александр Сергеевич - Система автоматизированного анализа качества структуры базы
        данных</title>

    <link href="../css/master_style.css" rel="stylesheet">
</head>

<body>

<div class="main-container">
    <nav>
        <div class="nav-item bio">
            <div class="avatar"></div>
            <p>Варяник Александр Сергеевич</p>
        </div>
        <div class="divider"></div>
        <div class="menu">
            <a class="menu-item" href="../index.html">
                Резюме
            </a>
            <a class="menu-item" href="../bio/index.html">
                Биография
            </a>
            <a class="menu-item" href="../diss/index.html">
                Реферат
            </a>
            <a class="menu-item active" href="index.html">
                Библиотека
            </a>
            <a class="menu-item" href="../links/index.html">
                Ссылки
            </a>
            <a class="menu-item" href="../ind/index.html">
                Индивидуальный раздел
            </a>
        </div>
    </nav>

    <main>
        <header>
            <div class="header-links">
                <p class="since">Научный руководитель: <a target="_blank"
                                                          href="http://masters.donntu.org/2003/fvti/greeschenko/index.htm">доц.
                    Грищенко Виктор Игоревич</a></p>
                <div class="sites">
                    <a target="_blank" href="http://www.donntu.org/">ДонНТУ</a>
                    <a target="_blank" href="http://masters.donntu.org/">Портал магистров</a>
                </div>
            </div>
            <p class="main-header">Система автоматизированного анализа качества структуры базы данных</p>
            <p class="sub-header">Как правильно использовать статический анализ</p>
        </header>
        <div id="article" class="main-content">
            <div class="link-body">
                <p class="link-info">
                    <span class="link-info-title">Авторы:</span>
                    Блог компании Ростелеком-Solar
                </p>
                <p class="link-info">
                    <span class="link-info-title">Источник:</span>
                    <a class="link" target="_blank"
                       href="https://habr.com/company/solarsecurity/blog/424255/">
                        Habrahabr
                    </a>
                </p>
                <p class="title"></p>
                <p>
                    Сейчас все больше говорят о статическом анализе для поиска уязвимостей как необходимом этапе
                    разработки. Однако многие говорят и о проблемах статического анализа. Об этом много говорили на
                    прошлом Positive Hack Days, и по итогам этих дискуссий мы уже писали о том, как устроен статический
                    анализатор. Если вы пробовали какой-нибудь серьезный инструмент, вас могли отпугнуть длинные отчеты
                    с запутанными рекомендациями, сложности настройки инструмента и ложные срабатывания. Так все-таки
                    нужен ли статический анализ?
                </p>
                <p>
                    Наш опыт подсказывает, что нужен. И многие проблемы, которые возникают при первом взгляде на
                    инструмент, вполне можно решить. Попробую рассказать, что может делать пользователь и каким должен
                    быть анализатор, чтобы его использование было полезным, а не вносило «еще один ненужный инструмент,
                    который требуют безопасники».
                </p>
                <p class="title">Про статический анализ</p>
                <p>
                    Итак, мы уже говорили о теоретических ограничениях статического анализа. Например, глубокий
                    статический анализ пытается решить экспоненциальные по сложности задачи. Поэтому каждый инструмент
                    ищет компромисс между временем работы, затрачиваемыми ресурсами, количеством найденных уязвимостей и
                    количеством ложных срабатываний.
                </p>
                <p>
                    Зачем вообще нужен глубокий анализ? Любая IDE очень быстро находит ошибки, иногда даже связанные с
                    безопасностью – какие вообще экспоненциальные задачи? Классический пример – SQL-инъекция (да и любая
                    другая инъекция, типа XSS, RCE и подобного), которая проходит через несколько функций (то есть
                    чтение данных от пользователя и выполнение запроса происходят в разных функциях). Для ее поиска
                    нужен межпроцедурный анализ потока данных, а это задача экспоненциальной сложности. Согласитесь, без
                    поиска таких уязвимостей анализ не может считаться глубоким. По этой же причине анализировать нужно
                    код целиком, а не частями – иначе можно упустить межпроцедурные уязвимости.
                </p>
                <p>
                    В последние годы я получил немало опыта общения с (потенциальными) заказчиками разных статических
                    анализаторов. В том числе мы обсуждаем претензии к инструментам по результатам первого использования
                    (пилота). Большинство претензий так или иначе следуют из теоретических ограничений технологии.
                    Помимо этого, инструменты могут просто не иметь нужного пользователю функционала. Однако, по моему
                    мнению, анализаторы могут двигаться (и двигаются) в сторону пользователя в плане решения
                    обозначенных дальше проблем. Но и нужно уметь пользоваться анализаторами, нивелируя последствия этих
                    же проблем – как оказывается, это не так сложно. Давайте по порядку.
                </p>
                <p>
                    Можно представить модельную ситуацию: вы решили попробовать технологию в действии или выбираете
                    статический анализатор – проводите пилот. Конечно, вы не доверяете тестовым примерам вендора и
                    хотите попробовать проанализировать свой код (заодно можно найти реальные уязвимости и исправить
                    их). Вам предоставляют инсталлятор или готовую виртуальную машину с системой на небольшой срок.
                </p>

                <p class="title">Запуск анализа</p>
                <p>
                    Сперва надо запустить анализ. Вы заходите в интерфейс, и, вроде бы, все должно быть понятно:
                    загружаем в форму архив с исходным кодом и нажимаем «анализировать». Но нет: вы получаете несколько
                    форм с разными полями, которые нужно как-то заполнить. Надо указать языки программирования, какие-то
                    настройки анализатора, выбрать пакеты уязвимостей (откуда вы знаете, что в них входит?) и так далее.
                    Вы проходите это испытание, и анализ начинается. А, нет – ошибка сканирования. «Формат не
                    соответствует требованиям», «Для данного языка требуется сборка кода», «Не найдено файлов для
                    сканирования»… Если вы не сами писали этот код, надо будет еще идти за помощью к разработчикам.
                </p>
                <p>
                    Отдельного внимания заслуживают требования к сборке кода. Большинство анализаторов для ряда языков
                    требуют, чтобы код собирался во время анализа (JVM-языки — Java, Scala, Kotlin и тому подобные,
                    C/C++, Objective-C, C#). Сами понимаете, какая это боль: воспроизвести окружение большого проекта
                    для сборки на новой машине. С другой стороны, эти требования оправданы, они следуют из технологии
                    анализа и специфики данных языков.
                </p>
                <p>
                    Как решают эти проблемы анализаторы? Во-первых, делают запуск анализа максимально
                    автоматизированным.
                    В идеале, достаточно загрузить файл любого формата, и анализатор сам должен понять, какие там языки,
                    как попробовать провести сборку и как проставить по умолчанию остальные настройки, чтобы результаты
                    были максимально полными. Понятно, что нельзя предусмотреть все – однако можно постараться
                    обрабатывать большую часть случаев.
                </p>
                <p>
                    Требования к сборке нужно делать максимально мягкими. Например, для JVM-языков не нужно требовать
                    сборки во время анализа – достаточно просить подгружать артефакты, то есть собранный код вместе с
                    исходниками (а это существенно проще). Для XCode в случае Objective-C сборку можно автоматизировать
                    для большинства случаев. Если не получилось собрать код, анализатор может попробовать провести
                    частичный анализ. Его результаты будут не настолько полными, но это лучше, чем никаких результатов
                    вообще. Также удобно, если модуль анализа можно поставить на машину к разработчику, где сборка кода
                    уже настроена, при этом архитектура должна позволять вынести остальные модули и интерфейсную часть
                    на другую машину.
                </p>
                <p>
                    Наконец, анализатор должен выдвигать максимально мягкие требования к формату и сам разбираться со
                    входными файлами. Архив с исходным кодом, вложенные архивы, архив из репозитория, ссылка на
                    репозиторий, архив с продуктива, исполняемый файл с продуктива – хорошо, если все это анализатор
                    поддерживает.
                </p>
                <p>
                    Однако не стоит забывать, что анализатор не обладает искусственным интеллектом и всего предусмотреть
                    не может. Поэтому при возникновении ошибок стоит ознакомиться с мануалом – там бывает много
                    полезного по подготовке кода для анализа. Ну, и вся эта работа по запуску сканирования при внедрении
                    анализатора проделывается только один раз для каждой кодовой базы. Чаще всего анализатор вообще
                    встраивается в цикл CI, то есть проблем со сборкой не будет.
                </p>

                <p class="title">Процесс анализа</p>

                <p>
                    Ладно, сканирование запустили. Проходит час – результатов нет. Прогресс бар висит где-то посередине,
                    непонятно с каким процентом и каким прогнозом по завершению. Проходит второй час – прогресс
                    сдвинулся на 99 процентов и висит там уже полчаса. Проходит третий час – и анализатор падает,
                    сообщая о нехватке оперативной памяти. Или висит еще час и завершается. Вы могли ожидать, что анализ
                    пройдет с той же скоростью, как ваш checkstyle, и тут ожидания сильно разойдутся с реальностью.
                </p>
                <p>
                    Да, хороший статический анализатор может потреблять немало ресурсов, одну из причин выше я указал:
                    нахождение сложных уязвимостей – экспоненциально сложная задача. Так что чем больше будет ресурсов и
                    чем больше времени, тем качественнее будут результаты (при хорошем движке, конечно). И время
                    анализа, и требуемые ресурсы предсказать действительно трудно – время работы алгоритмов статического
                    анализа сильно зависит от языковых конструкций, от сложности кода, от глубины вызовов – от
                    характеристик, которые сложно заранее просчитать.
                </p>
                <p>
                    Проблема с ресурсами – необходимое зло. Нужно внимательно относиться к выделению необходимых
                    ресурсов, терпеливо ждать окончания сканирования, а также понимать, что точно спрогнозировать
                    необходимые для анализатора ресурсы, даже при заданной кодовой базе, никто не сможет, и надо быть
                    готовым к изменению этих параметров. Более того, требуемые параметры могут измениться даже без
                    обновления кодовой базы – из-за обновления анализатора.
                </p>
                <p>
                    Все же и с этой проблемой анализатор может немного помочь. Он способен разделять по разным машинам
                    ресурсоемкую часть (движки) и интерфейс. Это позволит не загружать машины лишними программами,
                    которые будут тормозить их работу, при этом можно будет пользоваться интерфейсом системы при любой
                    загруженности по сканированиям (например, для просмотра и редактирования результатов). Еще это
                    позволит легко масштабироваться без переустановок всей системы (поднимаем анализатор на новой
                    виртуалке, указываем IP основной машины – и вуаля).

                </p>
                <p>
                    Помимо этого, анализатор может разрешать выбирать глубину анализа, отключать тяжеловесные проверки,
                    использовать инкрементальный анализ (при котором проверяется не весь код, а только изменившийся).
                    Этими вещами нужно пользоваться очень аккуратно, так как они могут сильно влиять на результаты
                    сканирования. Если вы пользуетесь такой функциональностью, рекомендуется с некоторой периодичностью
                    проводить полный анализ.
                </p>

                <p class="title">Результаты анализа</p>
                <p>
                    Перейдем к результатам сканирования (долго же мы до них шли). Вы с трепетом ждете количества
                    уязвимостей в окошке анализатора, и очень удивляетесь, увидев его. 156 критических, 1260 среднего и
                    3210 низкого уровня. Вы заходите на страницу с результатами и утопаете в количестве найденных
                    проблем. Вы выгружаете pdf-отчет – и видите несколько тысяч страниц текста. Угадайте, что скажет
                    разработчик кода, увидев такое полотно?
                </p>
                <p>
                    Но давайте все-таки попробуем посмотреть результаты, дадим ему шанс. Изучив повнимательнее несколько
                    десятков вхождений, вы начинаете понимать, почему уязвимостей так много. Несколько уязвимости и
                    правда выглядят серьезными, вы понимаете, что их нужно исправлять. Однако сходу вы находите с
                    десяток ложных. А еще – огромное количество уязвимостей в коде библиотек. Не будете же вы исправлять
                    библиотеки! И тут вы понимаете, сколько времени вы потратите на разбор результатов. И эту процедуру
                    надо повторять каждую день, неделю, ну или как минимум каждый релиз. (На самом деле нет).
                </p>
                <p>
                    Начнем с того, что ложность срабатывания можно понимать очень по-разному. Кто-то не будет считать
                    ложными только критические уязвимости, которые можно эксплуатировать прямо сейчас. Кто-то будет
                    считать ложными только откровенные ошибки анализатора. Многое зависит от того, чего вы хотите от
                    инструмента. Мы рекомендуем рассматривать практически все вхождения, так как даже уязвимость низкого
                    уровня, которую сейчас нельзя проэксплуатировать, завтра может обернуться серьезной проблемой –
                    например, при изменениях кода и внешних условий.
                </p>
                <p>
                    Ок, смотреть надо все вхождения, но это все еще огромный объем работы. И вот здесь анализаторы могут
                    помочь очень хорошо. Важнейшая функция анализатора – это умение отслеживать уязвимости между
                    сканированиями одного проекта, при этом отслеживать устойчиво к небольшим изменениям, стандартным
                    для разработки кода. Это снимает проблему того, что длительный разбор уязвимостей нужно повторять: в
                    первый раз вы потратите больше времени, удаляя ложные срабатывания и меняя критичность вхождений,
                    однако далее вам нужно будет просматривать только новые уязвимости, которых будет в разы меньше.
                </p>
                <p>
                    Хорошо, но нужно ли в первый раз просматривать все уязвимости? Мы рекомендуем это делать, но, вообще
                    говоря, это необязательно. Во-первых, анализаторы позволяют фильтровать результаты по директориям и
                    файлам: например, при запуске сканирования вы можете сразу исключить из анализа какие-то компоненты,
                    библиотеки, тестовый код. Это повлияет и на скорость анализа. Во-вторых, анализаторы позволяют
                    фильтровать результаты по уязвимостям, то есть при старте сканирования можно ограничить набор
                    уязвимостей. Наконец, помимо критичности анализатор может выдавать что-то вроде вероятности ложности
                    уязвимости (то есть свою уверенность в данной уязвимости). Используя эту метрику, можно фильтровать
                    результаты.
                </p>
                <p>
                    Отдельно стоит отметить технологию Software Composition Analysis (ее сейчас начинает поддерживать
                    все большее количество инструментов на разном уровне). Технология позволяет обнаруживать
                    использование библиотек в вашем коде, определять названия и версии, показывать известные уязвимости,
                    а также лицензии. Эта технология может отделить библиотечный код от вашего собственного, что также
                    позволит фильтровать результаты.
                </p>
                <p>
                    Получается, с проблемой обильных результатов анализа бороться можно, и это не очень сложно. И хотя
                    первый просмотр результатов действительно может занять время, далее при пересканировании его будет
                    тратиться все меньше. Однако еще раз отмечу, что к любой фильтрации результатов надо относиться
                    осторожно – вы можете пропустить уязвимость. Даже если библиотека является известной, не значит, что
                    в ней нет уязвимости. Если сейчас данная уязвимость обнаруживается плохо (то есть инструмент
                    показывает много ложных срабатываний этой уязвимости), и вы ее отключаете, при обновлении
                    анализатора вы можете пропустить уже настоящую уязвимость.
                </p>

                <p class="title">Резюме</p>
                <p>
                    В статье собраны основные рекомендации по началу использования статического анализатора. Хороший
                    анализатор работает на порядок лучше любого легковесного чекера, он ищет проблемы принципиально
                    другой сложности. Поэтому нужно считаться с особенностями статического анализа как технологии, но
                    при этом выбирать конкретный инструмент так, чтобы его функционал максимально сглаживал все такие
                    особенности.
                </p>
            </div>
        </div>
    </main>
</div>
</body>

</html>
